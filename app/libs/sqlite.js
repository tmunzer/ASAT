var file = "./asat.sqlite";
var sqlite3 = require("sqlite3");
var fs = require("fs");

var Sqlite = function(){
    var exists = fs.existsSync(file);
    var db = new sqlite3.Database(file);
    this.db = db;
    this.db.serialize(function() {
        if(!exists) {
            console.log('DB Error!!!');
        }
    });
};

Sqlite.prototype.customSelect = function (table, filter_string, callback) {
    console.log('SELECT * FROM ' + table + " WHERE " + filter_string);
    this.db.all('SELECT * FROM ' + table + " WHERE " + filter_string, function (err, ret) {
        if (err) {
            console.log(err);
        }
        callback(err, ret);
    });
};

Sqlite.prototype.customJoin = function (fields, table1, table2, table1JoinId, table2JoinId, filterString, callback) {
    if (fields == null) {
        fields = "*";
    }
    var queryString = 'SELECT ' + fields + ' FROM ' + table1 + " INNER JOIN " + table2 +
        " ON " + table1JoinId + " = " + table2JoinId +
        " WHERE " + filterString;
    console.log(queryString);
    this.db.all(queryString, function (err, ret) {
        if (err) {
            console.log(err);
        }
        callback(err, ret);
    });
};

Sqlite.prototype.updateDB = function (table, rowId, entries, callback) {
    var updateString = "";
    var fieldNumber = 0;
    for (var entry in entries) {
        if (entry == 'password' || entry == "sshPassword") {
            if (entries[entry] != "") {
                if (fieldNumber != 0) {
                    updateString += ",  ";
                }
                if (entry == 'sshPassword') {
                    updateString += entry + "='" + entries[entry] + "'";
                } else {
                    updateString += entry + "='" + createHash(entries[entry]) + "'";
                }
                fieldNumber++;
            }
        } else {
            if (fieldNumber != 0) {
                updateString += ",  ";
            }
            updateString += entry + "='" + entries[entry] + "'";
            fieldNumber++;
        }
    }
    updateString = 'UPDATE ' + table + ' SET ' + updateString + ' WHERE id=' + rowId + ";";
    console.log(updateString);
    this.db.run(updateString, function (err) {
        if (err) {
            console.log(err);
        }
        callback(err);
    })
};

Sqlite.prototype.insertDB = function (table, rows, callback) {
    var insertFields = "";
    var insertValues = "";
    var fieldNumber = 0;
    for (var field in rows) {
        if (fieldNumber != 0) {
            insertFields += ",  ";
            insertValues += ",  ";
        }
        if (field == 'password') {
            if (rows[field] != "") {
                insertFields += field;
                insertValues += "'" + createHash(rows[field]) + "'";
                fieldNumber++;
            }
        } else {
            insertFields += field;
            insertValues += '"' + rows[field] + '"';
            fieldNumber++;
        }
    }
    var insertString = 'INSERT INTO ' + table + ' (' + insertFields + ') VALUES (' + insertValues + ");";
    console.log(insertString);
    this.db.run(insertString, function (err) {
        if (err) {
            console.log(err);
        }
        callback(err, this.lastID);
    });
};

processOptions = function (rOptions) {
    var options = rOptions || {};
    var columnsString = "";
    var orderByString = "";
    var optionNumber = 0;
    if (options.hasOwnProperty("columns")) {
        optionNumber = 0;
        for (var column in options['columns']) {
            if (optionNumber != 0) {
                columnsString += ", ";
            }
            columnsString += options['columns'][column];
            optionNumber++;
        }
    } else {
        columnsString = "*";
    }
    if (options.hasOwnProperty("orderBy")) {
        orderByString = " ORDER BY " + options['orderBy'];
    } else {
        orderByString = "";
    }
    return {"columns": columnsString, "orderBy": orderByString};
};

processFilters = function (filters) {
    var filterString = "";
    if (filters != null) {
        var filterNum = 0;
        for (var filterName in filters) {
            if (filterNum != 0) {
                filterString += " AND "
            }
            filterString += filterName + "='" + filters[filterName] + "'";
            filterNum++;
        }
        filterString = " WHERE (" + filterString + ")";
    }
    return filterString;
};

Sqlite.prototype.findOne = function (table, filters, options, callback) {
    /**
     Find the first row matching the fields
     Table: Table to request
     Fields: object {fieldName: fieldValue}
     Options: object {option: []} with the following options (optionals)
     columns: columns to retrieve
     orderBy: how to sort the result
     */
    var filterString = processFilters(filters);
    var rOptions = processOptions(options);
    var selectString = "SELECT " + rOptions.columns + " FROM " + table + filterString;
    console.log(selectString);
    this.db.get(selectString, function (err, ret) {
        if (err) {
            console.log(err);
        }
        callback(err, ret);
    });
};

Sqlite.prototype.findAll = function (table, filters, options, callback) {
    /**
     Find the rows matching the fields
     Table: Table to request
     Fields: object {fieldName: fieldValue}
     Options: object {option: []} with the following options (optionals)
     columns: columns to retrieve
     orderBy: how to sort the result
     */
    var filterString = processFilters(filters);
    var rOptions = processOptions(options);
    var selectString = "SELECT " + rOptions.columns + " FROM " + table + filterString;
    console.log(selectString);
    this.db.all(selectString, function (err, ret) {
        if (err) {
            console.log(err);
        }
        callback(err, ret);
    });
};

Sqlite.prototype.findById = function (table, rowId, filters, options, callback) {
    /**
     Get one row by its ID
     Table: Table to request
     Options: object {option: []} with the following options (optionals)
     columns: columns to retrieve
     orderBy: how to sort the result
     */
    if (rowId >= 0) {
        var rOptions = processOptions(options);
        filters = filters || {};
        filters['id'] = rowId;
        var filterString = processFilters(filters);
        var getString = "SELECT " + rOptions.columns + " FROM " + table + filterString;
        console.log("FindById: " + getString);
        this.db.get(getString, function (err, ret) {
            if (err && err != "") {
                console.log(err);
                console.log(ret);
            }
            callback(err, ret);
        });
    } else {
        callback(null, null);
    }

};


Sqlite.prototype.deleteById = function (table, rId, callback) {
    this.db.run("DELETE FROM " + table + " WHERE id = " + rId, function (err, ret) {
        if (err) {
            console.log(err);
        }
        callback(err, ret);
    });
};

module.exports.init = Sqlite;

